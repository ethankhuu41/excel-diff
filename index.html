<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Excel/CSV Compare & Merge — 3-Pane UI + Shortcuts</title>
<link rel="icon" href="data:,">
<script src="https://cdn.tailwindcss.com"></script>
<script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<style>
  :root { --hl:#fff3c4 }
  .cell-mod { background: var(--hl) }
  .cell-missing { background-image: repeating-linear-gradient(45deg,#f3f4f6,#f3f4f6 6px,#e5e7eb 6px,#e5e7eb 12px) }
  .badge { font-size:10px; line-height:1; padding:2px 4px; border-radius:4px; color:#fff; background:#111; }
  .sticky-top { position: sticky; top: 0; z-index: 20; background: white; }
  .sticky-bottom { position: sticky; bottom: 0; z-index: 20; background: white; }
  .row-hover:hover { background:#fafafa }
  .scrollbar-thin::-webkit-scrollbar { height: 8px; width: 8px; }
  .scrollbar-thin::-webkit-scrollbar-thumb { background:#d1d5db; border-radius:6px; }
</style>
</head>
<body class="h-screen">
<div id="app" class="h-full"></div>

<script>
const {useState,useMemo,useRef,useEffect,useCallback} = React;

/* utils */
const esc = (s)=> (s==null?"":String(s));
const trim = (s)=> esc(s).trim();
const shallowCopy = (o)=> Object.assign({}, o);
const keyFor = (rowKey,col)=> `${rowKey}|${col}`;

/* xlsx helpers */
function ensureXLSX(){ if(typeof XLSX==='undefined') throw new Error('XLSX not loaded'); }
async function readWorkbook(file){ ensureXLSX(); const buf=await file.arrayBuffer(); return XLSX.read(buf,{type:'array'}); }
function sheetToRows(wb, sheet){
  const name = (sheet && wb.Sheets[sheet]) ? sheet : wb.SheetNames[0];
  const ws = wb.Sheets[name]; if(!ws) return {headers:[],rows:[]};
  const arr = XLSX.utils.sheet_to_json(ws,{header:1,defval:""});
  if(!arr.length) return {headers:[],rows:[]};
  const headers = arr[0].map(h=>trim(h));
  const rows = arr.slice(1).map(r=>{
    const o={}; for(let i=0;i<headers.length;i++) o[headers[i]] = trim(r[i] ?? '');
    return o;
  }).filter(o=> Object.values(o).some(v=>v!==''));
  return {headers,rows};
}
function writeXLSX(filename, headers, rows){
  const aoa=[headers]; rows.forEach(r=> aoa.push(headers.map(h=> esc(r[h]??""))));
  const ws = XLSX.utils.aoa_to_sheet(aoa); const wb = XLSX.utils.book_new();
  XLSX.utils.book_append_sheet(wb, ws, 'Merged'); XLSX.writeFile(wb, filename);
}

/* diff */
function unionHeaders(a,b){ const s=new Set(a); b.forEach(h=>s.add(h)); return [...s]; }
function normalizeRow(row, headers, {trimSpaces,caseInsensitive}){
  const o={}; headers.forEach(h=>{
    let v = esc(row[h] ?? '');
    if(trimSpaces) v = v.trim();
    if(caseInsensitive) v = v.toLowerCase();
    o[h]=v;
  }); return o;
}
function indexBy(rows, key){ const m=new Map(); rows.forEach(r=>{ const k=r[key]; if(k!=null)m.set(String(k), r);}); return m; }
function computeDiff({Arows,Brows,headers,key}) {
  const mapA=indexBy(Arows,key), mapB=indexBy(Brows,key);
  const keysA=[...mapA.keys()], keysB=[...mapB.keys()];
  const setA=new Set(keysA), setB=new Set(keysB);
  const added=[], removed=[], modified=[], unchanged=[];
  keysB.forEach(k=>{
    if(!setA.has(k)) { added.push(k); }
    else{
      const a = mapA.get(k), b = mapB.get(k);
      let changed=false;
      headers.forEach(h=>{
        if(h===key) return;
        if(esc(a[h])!==esc(b[h])) changed=true;
      });
      if(changed) modified.push(k); else unchanged.push(k);
    }
  });
  keysA.forEach(k=>{ if(!setB.has(k)) removed.push(k); });
  const cells=[];
  const allKeys=[...new Set([...keysA,...keysB])];
  allKeys.forEach(rowKey=>{
    const a = mapA.get(rowKey) || {};
    const b = mapB.get(rowKey) || {};
    headers.forEach(col=>{
      if(col===key) return;
      const hasA = a[col]!=null && a[col]!=='';
      const hasB = b[col]!=null && b[col]!=='';
      const equal = esc(a[col])===esc(b[col]);
      cells.push({ rowKey, column: col, left: a[col]??'', right: b[col]??'', equal, missingLeft: !hasA, missingRight: !hasB });
    });
  });
  return { mapA, mapB, added, removed, modified, unchanged, cells };
}

/* csv */
function toCSV(headers, rows){
  const escq=(v)=>{ const s=esc(v); return /[",\n]/.test(s) ? '"'+s.replace(/"/g,'""')+'"' : s; };
  const lines=[headers.map(escq).join(",")];
  rows.forEach(r=> lines.push(headers.map(h=> escq(r[h]??"")).join(",")));
  return lines.join("\n");
}
function toDiffCSV(headers, key, {added,removed,modified}, {mapA,mapB}){
  const other=headers.filter(h=>h!==key);
  const head=["ChangeType",key,...other, ...other.flatMap(h=>[h+"_old",h+"_new"])];
  const escq=(v)=>{ const s=esc(v); return /[",\n]/.test(s)?'"'+s.replace(/"/g,'""')+'"':s; };
  const lines=[head.map(escq).join(",")];
  added.forEach(k=>{
    const r=mapB.get(k)||{}; lines.push(["Added",k,...other.map(h=>esc(r[h]??"")), ...other.flatMap(()=>["",""])].map(escq).join(","));
  });
  removed.forEach(k=>{
    const r=mapA.get(k)||{}; lines.push(["Removed",k,...other.map(h=>esc(r[h]??"")), ...other.flatMap(()=>["",""])].map(escq).join(","));
  });
  modified.forEach(k=>{
    const a=mapA.get(k)||{}, b=mapB.get(k)||{};
    lines.push(["Modified",k,...other.map(h=>esc(b[h]??"")), ...other.flatMap(h=>[esc(a[h]??""),esc(b[h]??"")])].map(escq).join(","));
  });
  return lines.join("\n");
}

/* history */
function useHistoryState(initial){
  const [state,setState]=useState(initial);
  const undoRef=useRef([]), redoRef=useRef([]);
  const apply=(updater)=>{
    undoRef.current.push(state);
    redoRef.current.length=0;
    setState(typeof updater==='function'? updater(state) : updater);
  };
  const undo=()=>{ const prev=undoRef.current.pop(); if(prev){ redoRef.current.push(state); setState(prev); } };
  const redo=()=>{ const next=redoRef.current.pop(); if(next){ undoRef.current.push(state); setState(next); } };
  return [state,apply,undo,redo];
}

/* app */
function App(){
  const [files,setFiles]=useState({A:null,B:null});
  const [names,setNames]=useState({A:'',B:''});
  const [sheet,setSheet]=useState('');
  const [headers,setHeaders]=useState([]);
  const [key,setKey]=useState('');
  const [maps,setMaps]=useState({mapA:new Map(),mapB:new Map()});
  const [sets,setSets]=useState({added:[],removed:[],modified:[],unchanged:[]});
  const [cells,setCells]=useState([]);
  const [ui,applyUI,undoUI,redoUI]=useHistoryState({
    filters:{showEqual:true,onlyModified:false,onlyAdded:false,onlyRemoved:false, trim:false, ci:false},
    resolutions:{}, columnRules:[], selection:null
  });
  const [ready,setReady]=useState(false);
  const gridRef=useRef(null);
  const searchRef=useRef(null);
  const [toast,setToast]=useState('');
  const [preview,setPreview]=useState({open:false, rows:[]});

  const counters = { Added: sets.added.length, Removed: sets.removed.length, Modified: sets.modified.length, Unchanged: sets.unchanged.length };

  const handleCompare = async ()=>{
    try{
      if(!files.A || !files.B) throw new Error('Select both files');
      setToast('Parsing…');
      const [wbA,wbB] = await Promise.all([readWorkbook(files.A), readWorkbook(files.B)]);
      const A = sheetToRows(wbA, sheet || undefined);
      const B = sheetToRows(wbB, sheet || undefined);
      if(!A.headers.length || !B.headers.length) throw new Error('Missing headers');
      const allHeaders = unionHeaders(A.headers,B.headers);
      const k = key || A.headers[0];
      const Arows = A.rows.map(r=> normalizeRow(r, allHeaders, {trimSpaces:ui.filters.trim, caseInsensitive:ui.filters.ci}));
      const Brows = B.rows.map(r=> normalizeRow(r, allHeaders, {trimSpaces:ui.filters.trim, caseInsensitive:ui.filters.ci}));
      const {mapA,mapB,added,removed,modified,unchanged,cells} = computeDiff({Arows,Brows,headers:allHeaders,key:k});
      setHeaders(allHeaders); setKey(k); setCells(cells); setMaps({mapA,mapB}); setSets({added,removed,modified,unchanged});
      setNames({A:files.A.name,B:files.B.name}); setReady(true); setToast('Done.');
      setTimeout(()=> gridRef.current?.focus(), 0);
    }catch(e){ setToast(e.message||String(e)); }
  };

  const filteredRowKeys = useMemo(()=>{
    const allKeys = new Set([...maps.mapA.keys(), ...maps.mapB.keys()]);
    const out = [];
    allKeys.forEach(k=>{
      const isAdded = sets.added.includes(k);
      const isRemoved = sets.removed.includes(k);
      const isModified = sets.modified.includes(k);
      const isUnchanged = sets.unchanged.includes(k);
      if(ui.filters.onlyAdded && !isAdded) return;
      if(ui.filters.onlyRemoved && !isRemoved) return;
      if(ui.filters.onlyModified && !isModified) return;
      if(!ui.filters.showEqual && isUnchanged) return;
      out.push(k);
    });
    out.sort((a,b)=> String(a).localeCompare(String(b)));
    return out;
  },[maps,sets,ui.filters]);

  const buildMerged = ()=>{
    const resMap = new Map(maps.mapA);
    filteredRowKeys.forEach(k=>{
      const rowA = maps.mapA.get(k), rowB = maps.mapB.get(k);
      if(sets.added.includes(k)){
        const r = ui.resolutions[keyFor(k,'__ROW__')];
        if(r?.kind==='right') resMap.set(k, rowB);
      }
      if(sets.removed.includes(k)){
        const r = ui.resolutions[keyFor(k,'__ROW__')];
        if(r?.kind==='left') resMap.set(k, rowA); else resMap.delete(k);
      }
      if(sets.modified.includes(k)){
        const base = shallowCopy(rowA || {});
        headers.forEach(col=>{
          if(col===key) { base[col] = (rowA?.[col]) ?? (rowB?.[col]) ?? ''; return; }
          const rule = ui.columnRules.find(r=>r.column===col);
          const res = ui.resolutions[keyFor(k,col)];
          let val = (rowA?.[col]) ?? '';
          let valB = (rowB?.[col]) ?? '';
          if(rule){
            if(rule.rule==='preferRight') val = valB;
            else if(rule.rule==='preferLeft') val = val;
            else if(rule.rule==='preferLeftIfRightBlank') val = (valB===''? val : valB);
            else if(rule.rule==='preferLarger'){
              const na = Number(val), nb = Number(valB);
              if(!Number.isNaN(na) && !Number.isNaN(nb)) val = (nb>na? valB : val);
            }else if(rule.rule==='preferSmaller'){
              const na = Number(val), nb = Number(valB);
              if(!Number.isNaN(na) && !Number.isNaN(nb)) val = (nb<na? valB : val);
            }else if(rule.rule==='normalize'){
              const t = (x)=> esc(x).trim();
              val = t(val); valB = t(valB);
            }
          }
          if(res?.kind==='right') val = valB;
          else if(res?.kind==='custom') val = esc(res.value);
          base[col] = val;
        });
        resMap.set(k, base);
      }
    });
    const out=[]; resMap.forEach(v=> out.push(v));
    out.sort((a,b)=> esc(a?.[key]).localeCompare(esc(b?.[key])));
    return out;
  };

  /* resolutions */
  const setRowChoice = (rowKey, choice)=> applyUI(d=>{
    const cp = {...d}; cp.resolutions = {...cp.resolutions, [keyFor(rowKey,'__ROW__')]: {kind: choice} }; return cp;
  });
  const setCellChoice = (rowKey,col, choice)=> applyUI(d=>{
    const cp = {...d}; cp.resolutions = {...cp.resolutions, [keyFor(rowKey,col)]: choice}; return cp;
  });
  const preferInRow = (rowKey, side)=> applyUI(d=>{
    const cp={...d}; headers.forEach(col=>{
      if(col===key) return;
      const a = maps.mapA.get(rowKey)?.[col] ?? '';
      const b = maps.mapB.get(rowKey)?.[col] ?? '';
      if(esc(a)!==esc(b)) cp.resolutions[keyFor(rowKey,col)] = {kind: side};
    }); return cp;
  });
  const toggleFilterChip = (chip)=> applyUI(d=>{
    const f={...d.filters};
    if(chip==='Hide equal') f.showEqual = !f.showEqual;
    if(chip==='Only modified') f.onlyModified = !f.onlyModified;
    if(chip==='Only added') f.onlyAdded = !f.onlyAdded;
    if(chip==='Only removed') f.onlyRemoved = !f.onlyRemoved;
    if(chip==='Trim spaces') f.trim = !f.trim;
    if(chip==='Case-insensitive') f.ci = !f.ci;
    return {...d, filters:f};
  });
  const addColumnRule = (column, rule)=> applyUI(d=> ({...d, columnRules:[...d.columnRules.filter(r=>r.column!==column), {column, rule}]}));
  const clearColumnRule = (column)=> applyUI(d=> ({...d, columnRules:d.columnRules.filter(r=>r.column!==column)}));
  const selectCell = (rowKey,col)=> applyUI(d=> ({...d, selection:{rowKey, column:col}}));

  /* keyboard shortcuts */
  useEffect(()=>{
    const handler = (e)=>{
      const tag = (e.target && e.target.tagName || '').toLowerCase();
      const inInput = tag==='input' || tag==='textarea' || e.target.isContentEditable;
      const k = e.key;
      if(k==='/'){ if(!inInput){ e.preventDefault(); searchRef.current?.focus(); } return; }
      if(k==='f' || k==='F'){ if(!inInput){ e.preventDefault(); toggleFilterChip('Only modified'); } return; }
      if(k==='p' || k==='P'){ if(!inInput){ e.preventDefault(); const rows = buildMerged(); setPreview({open:true, rows}); } return; }
      if(k==='u' || k==='U'){
        e.preventDefault();
        if(e.shiftKey) redoUI(); else undoUI();
        return;
      }
      if(k==='Escape' && preview.open){ e.preventDefault(); setPreview(p=>({...p, open:false})); return; }
    };
    window.addEventListener('keydown', handler);
    return ()=> window.removeEventListener('keydown', handler);
  }, [ui, preview.open, headers, sets, maps]);

  /* grid rows */
  const gridModel = useMemo(()=>{
    const rows = filteredRowKeys.map(k=>{
      const a = maps.mapA.get(k)||{}, b = maps.mapB.get(k)||{};
      const status = sets.added.includes(k) ? 'added' : sets.removed.includes(k) ? 'removed' : sets.modified.includes(k) ? 'modified' : 'unchanged';
      const cols = headers.filter(h=>h!==key).map(col=>{
        const left=a[col]??'', right=b[col]??'';
        const equal = esc(left)===esc(right);
        return {rowKey:k, column:col, left, right, equal, missingLeft: (left===''), missingRight:(right==='')};
      });
      return {rowKey:k, status, cells:cols};
    });
    return rows;
  },[filteredRowKeys,headers,maps,sets]);

  return (
    <div className="flex h-screen flex-col">
      {/* Top bar */}
      <div className="sticky-top border-b px-3 py-2">
        <div className="flex items-center justify-between gap-3">
          <div className="flex items-center gap-2 text-sm">
            <span className="font-medium">{names.A||'Left.xlsx'}</span>
            <span className="text-gray-400">▸</span>
            <span className="font-medium">{names.B||'Right.xlsx'}</span>
            {ready && <span className="ml-3 text-xs text-gray-500">Key: <b>{key}</b> • Columns: {headers.length}</span>}
          </div>
          <div className="flex items-center gap-2 text-xs">
            <Chip label={`Added ${counters.Added}`} onClick={()=>toggleFilterChip('Only added')} active={ui.filters.onlyAdded}/>
            <Chip label={`Removed ${counters.Removed}`} onClick={()=>toggleFilterChip('Only removed')} active={ui.filters.onlyRemoved}/>
            <Chip label={`Modified ${counters.Modified}`} onClick={()=>toggleFilterChip('Only modified')} active={ui.filters.onlyModified}/>
            <Chip label={`Unchanged ${counters.Unchanged}`} onClick={()=>toggleFilterChip('Hide equal')} active={!ui.filters.showEqual}/>
            <span className="mx-2 text-gray-300">|</span>
            <Chip label="Trim spaces" onClick={()=>toggleFilterChip('Trim spaces')} active={ui.filters.trim}/>
            <Chip label="Case-insensitive" onClick={()=>toggleFilterChip('Case-insensitive')} active={ui.filters.ci}/>
          </div>
        </div>
        {/* Upload + key picker */}
        <div className="mt-2 flex flex-wrap items-center gap-2 text-sm">
          <input type="file" className="border rounded px-2 py-1" onChange={e=> setFiles(s=>({...s,A:e.target.files[0]}))} accept=".xlsx,.xls,.csv"/>
          <input type="file" className="border rounded px-2 py-1" onChange={e=> setFiles(s=>({...s,B:e.target.files[0]}))} accept=".xlsx,.xls,.csv"/>
          <input type="text" placeholder="Worksheet (optional)" className="border rounded px-2 py-1" onChange={e=> setSheet(e.target.value)}/>
          <input type="text" placeholder="Key (blank = first col of A)" className="border rounded px-2 py-1" value={key} onChange={e=> setKey(e.target.value)}/>
          <button className="rounded bg-blue-600 text-white px-3 py-1" onClick={handleCompare}>Compare</button>
          <input ref={searchRef} className="ml-3 border rounded px-2 py-1 text-xs" placeholder="Search  ( / to focus )"/>
          <span className="text-xs text-gray-500">{toast}</span>
        </div>
      </div>

      {/* Main */}
      <div className="flex min-h-0 flex-1">
        {/* Left: grid */}
        <div className="flex-1 min-w-0">
          <DiffGrid
            refObj={gridRef}
            headers={headers}
            keyCol={key}
            rows={gridModel}
            ui={ui}
            sets={sets}
            onCellChoice={setCellChoice}
            onRowChoice={setRowChoice}
            onSelectCell={selectCell}
            onPreferRow={preferInRow}
            onAddColumnRule={(col,rule)=> addColumnRule(col,rule)}
            onClearColumnRule={clearColumnRule}
            searchRef={searchRef}
          />
        </div>
        {/* Right: details panel */}
        <aside className="w-[360px] border-l border-gray-200 shrink-0">
          <DetailsPanel
            selection={ui.selection}
            headers={headers}
            keyCol={key}
            maps={maps}
            onSetCell={setCellChoice}
            onPreset={(side)=> ui.selection?.rowKey && preferInRow(ui.selection.rowKey, side)}
          />
        </aside>
      </div>

      {/* Footer */}
      <div className="sticky-bottom border-t px-3 py-2 flex items-center justify-between">
        <div className="flex items-center gap-2">
          <button className="rounded bg-gray-800 text-white px-3 py-1" title="U" onClick={undoUI}>Undo</button>
          <button className="rounded bg-gray-800 text-white px-3 py-1" title="Shift+U" onClick={redoUI}>Redo</button>
          <BulkRulesHelp/>
        </div>
        <div className="flex items-center gap-2">
          <button className="rounded bg-slate-700 text-white px-3 py-1" title="P" onClick={()=>{ const rows=buildMerged(); setPreview({open:true, rows}); }}>Preview merged</button>
          <button className="rounded bg-emerald-600 text-white px-3 py-1" onClick={()=>{
            const merged = buildMerged(); writeXLSX('merged.xlsx', headers, merged);
          }}>Export XLSX</button>
          <button className="rounded bg-emerald-600 text-white px-3 py-1" onClick={()=>{
            const merged = buildMerged(); const csv = toCSV(headers, merged);
            download('merged.csv', 'text/csv;charset=utf-8;', csv);
          }}>Export CSV</button>
          <button className="rounded bg-amber-600 text-white px-3 py-1" onClick={()=>{
            const csv = toDiffCSV(headers, key, sets, maps);
            download('diff_audit.csv','text/csv;charset=utf-8;', csv);
          }}>Export Diff CSV</button>
        </div>
      </div>

      {/* Preview modal */}
      {preview.open && (
        <PreviewModal onClose={()=>setPreview(p=>({...p,open:false}))} headers={headers} rows={preview.rows}/>
      )}
    </div>
  );
}

/* components */
function Chip({label,active,onClick}){
  return <button className={"px-2 py-1 rounded border text-xs "+(active?"bg-blue-600 text-white border-blue-600":"bg-white text-gray-700")}
    onClick={onClick}>{label}</button>;
}
function BulkRulesHelp(){
  return <div className="text-xs text-gray-500">
    Bulk rules: column menu → Prefer Right/Left, Prefer larger/smaller, Normalize, Prefer Left if Right blank.
  </div>;
}
function DetailsPanel({selection, headers, keyCol, maps, onSetCell, onPreset}){
  if(!selection?.rowKey){
    return <div className="p-3 text-sm text-gray-500">Select a cell/row to review differences.</div>;
  }
  const k = selection.rowKey;
  const a = maps.mapA.get(k) || {};
  const b = maps.mapB.get(k) || {};
  const diffs = headers.filter(h=>h!==keyCol && (esc(a[h]??'')!==esc(b[h]??'')));
  return (
    <div className="p-3 space-y-3">
      <h3 className="font-semibold text-sm">Row {k}</h3>
      <div className="flex gap-2">
        <button className="rounded bg-gray-800 text-white px-2 py-1 text-xs" onClick={()=>onPreset('left')}>Prefer Left</button>
        <button className="rounded bg-gray-800 text-white px-2 py-1 text-xs" onClick={()=>onPreset('right')}>Prefer Right</button>
      </div>
      <div className="space-y-2 max-h-[70vh] overflow-auto pr-1">
        {diffs.map(col=>(
          <div key={col} className="border rounded p-2">
            <div className="text-xs text-gray-500">{col}</div>
            <div className="mt-1 grid grid-cols-2 gap-2 text-xs">
              <label className="flex items-center gap-2">
                <input type="radio" name={k+'|'+col} onChange={()=>onSetCell(k,col,{kind:'left'})}/>
                <span className="truncate">Left: {esc(a[col]??'')}</span>
              </label>
              <label className="flex items-center gap-2">
                <input type="radio" name={k+'|'+col} onChange={()=>onSetCell(k,col,{kind:'right'})}/>
                <span className="truncate">Right: {esc(b[col]??'')}</span>
              </label>
            </div>
            <div className="mt-2">
              <input className="w-full border rounded px-2 py-1 text-xs" placeholder="Custom value"
                onBlur={(e)=> onSetCell(k,col,{kind:'custom', value:e.target.value}) }/>
            </div>
          </div>
        ))}
      </div>
    </div>
  );
}
function DiffGrid({refObj, headers, keyCol, rows, ui, sets, onCellChoice, onRowChoice, onSelectCell, onPreferRow, onAddColumnRule, onClearColumnRule, searchRef}){
  const containerRef = useRef(null);
  const [scrollTop,setScrollTop]=useState(0);
  const rowHeight=32, buffer=8;
  const hAvail =  window.innerHeight - 140;
  const visibleCount = Math.max(10, Math.floor(hAvail/rowHeight));
  const total = rows.length;
  const start = Math.max(0, Math.floor(scrollTop/rowHeight)-buffer);
  const end = Math.min(total, start + visibleCount + buffer*2);
  const offsetTop = start*rowHeight;
  useEffect(()=>{ refObj.current = containerRef.current; },[]);
  const onScroll=(e)=> setScrollTop(e.target.scrollTop);

  useEffect(()=>{
    if(!searchRef?.current) return;
    const input = searchRef.current;
    const onChange=(e)=>{
      const q = e.target.value.toLowerCase();
      const nodes = containerRef.current?.querySelectorAll('[data-row]');
      if(!nodes) return;
      nodes.forEach(n=>{
        const t = (n.getAttribute('data-text')||'').toLowerCase();
        n.style.display = q && !t.includes(q) ? 'none' : '';
      });
    };
    input.addEventListener('input', onChange);
    return ()=> input.removeEventListener('input', onChange);
  },[]);

  return (
    <div className="h-full">
      {/* Header */}
      <div className="border-b grid text-xs font-medium" style={{gridTemplateColumns:`160px repeat(${headers.filter(h=>h!==keyCol).length}, minmax(120px, 1fr))`}}>
        <div className="px-2 py-2 sticky-top bg-white">Row</div>
        {headers.filter(h=>h!==keyCol).map(col=>(
          <div key={col} className="px-2 py-2">
            <div className="flex items-center justify-between gap-2">
              <span className="truncate" title={col}>{col}</span>
              <ColumnMenu column={col} onRule={(c,r)=>onAddColumnRule(c,r)} onClear={onClearColumnRule}/>
            </div>
          </div>
        ))}
      </div>

      {/* Body (virtualized) */}
      <div ref={containerRef} onScroll={onScroll} tabIndex={0}
           className="h-[calc(100vh-220px)] overflow-auto outline-none scrollbar-thin">
        <div style={{height: total*rowHeight+'px', position:'relative'}}>
          <div style={{transform:`translateY(${offsetTop}px)`}}>
            {rows.slice(start,end).map((r)=>{
              const k = r.rowKey;
              const isAdded = sets.added.includes(k);
              const isRemoved = sets.removed.includes(k);
              const rowText = JSON.stringify(r).slice(0,1000);
              return (
                <div key={k} data-row data-text={rowText}
                     className={"grid text-xs row-hover border-b"} style={{gridTemplateColumns:`160px repeat(${r.cells.length}, minmax(120px, 1fr))`, height:rowHeight}}>
                  {/* Row actions */}
                  <div className="px-2 flex items-center gap-2">
                    <span className="font-mono text-[11px]">{k}</span>
                    {isAdded && (
                      <label className="flex items-center gap-1">
                        <input type="checkbox" onChange={e=> onRowChoice(k, e.target.checked?'right':'unset')} />
                        <span>Add</span>
                      </label>
                    )}
                    {isRemoved && (
                      <label className="flex items-center gap-1">
                        <input type="checkbox" defaultChecked onChange={e=> onRowChoice(k, e.target.checked?'left':'unset')} />
                        <span>Keep</span>
                      </label>
                    )}
                    {!isAdded && !isRemoved && (
                      <button className="px-1 py-0.5 border rounded" onClick={()=> onPreferRow(k,'right')}>All B</button>
                    )}
                  </div>
                  {/* Cells */}
                  {r.cells.map(cell=>{
                    const isMod = !cell.equal;
                    const res = ui.resolutions[keyFor(cell.rowKey,cell.column)];
                    const chosen = res?.kind==='right' ? 'R' : res?.kind==='left' ? 'L' : res?.kind==='custom' ? '✎' : '';
                    const chosenValue = res?.kind==='right' ? cell.right : res?.kind==='custom' ? res.value : cell.left;
                    const title = `${esc(cell.left)}  ⇄  ${esc(cell.right)}`;
                    return (
                      <div key={cell.column}
                           className={"px-2 flex items-center justify-between gap-2 outline-none "+(isMod?'cell-mod':'')+" "+((cell.missingLeft||cell.missingRight)&&isMod?'cell-missing':'')}
                           tabIndex={0} title={title}
                           onKeyDown={(e)=>{
                             if(e.key==='Enter' || e.key===' ') onCellChoice(cell.rowKey, cell.column, res?.kind==='right'?{kind:'left'}:{kind:'right'});
                             if(e.key.toLowerCase()==='e'){
                               const v = prompt('Custom value', esc(chosen?chosenValue:cell.left)); if(v!=null) onCellChoice(cell.rowKey, cell.column, {kind:'custom', value:v});
                             }
                           }}
                           onClick={()=> onSelectCell(cell.rowKey, cell.column)}>
                        <span className="truncate">{isMod ? esc(chosen?chosenValue:cell.right) : esc(cell.left)}</span>
                        {chosen && <span className="badge" aria-label={chosen==='✎'?'Custom':(chosen==='R'?'Keep Right':'Keep Left')}>{chosen}</span>}
                      </div>
                    );
                  })}
                </div>
              );
            })}
          </div>
        </div>
      </div>
    </div>
  );
}
function ColumnMenu({column,onRule,onClear}){
  const [open,setOpen]=useState(false);
  return (
    <div className="relative">
      <button className="px-1 py-0.5 border rounded" onClick={()=>setOpen(o=>!o)} aria-haspopup="menu" aria-expanded={open}>⋮</button>
      {open && (
        <div className="absolute right-0 mt-1 w-56 bg-white border rounded shadow text-xs z-30">
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'preferRight'); setOpen(false);}}>Prefer Right</button>
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'preferLeft'); setOpen(false);}}>Prefer Left</button>
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'preferLeftIfRightBlank'); setOpen(false);}}>If Right blank, keep Left</button>
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'preferLarger'); setOpen(false);}}>Numeric: prefer larger</button>
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'preferSmaller'); setOpen(false);}}>Numeric: prefer smaller</button>
          <button className="block w-full text-left px-2 py-1 hover:bg-gray-50" onClick={()=>{onRule(column,'normalize'); setOpen(false);}}>Normalize (trim/case)</button>
          <div className="border-t my-1"></div>
          <button className="block w-full text-left px-2 py-1 text-red-600 hover:bg-red-50" onClick={()=>{onClear(column); setOpen(false);}}>Clear rule</button>
        </div>
      )}
    </div>
  );
}
function PreviewModal({onClose, headers, rows}){
  return (
    <div className="fixed inset-0 bg-black/40 z-40 flex items-center justify-center" onClick={onClose}>
      <div className="bg-white rounded shadow-xl max-w-[90vw] max-h-[80vh] w-[900px] overflow-auto" onClick={e=>e.stopPropagation()}>
        <div className="px-4 py-2 border-b flex items-center justify-between sticky top-0 bg-white">
          <h3 className="font-semibold text-sm">Merged preview ({rows.length} rows)</h3>
          <button className="px-2 py-1 border rounded text-xs" onClick={onClose}>Esc to close</button>
        </div>
        <div className="p-3">
          <div className="overflow-auto border rounded">
            <table className="text-xs min-w-full">
              <thead className="sticky top-0 bg-white">
                <tr>{headers.map(h=><th key={h} className="px-2 py-1 border-b text-left">{h}</th>)}</tr>
              </thead>
              <tbody>
                {rows.slice(0,1000).map((r,i)=>(
                  <tr key={i} className="odd:bg-gray-50">
                    {headers.map(h=><td key={h} className="px-2 py-1 border-b">{esc(r[h]??'')}</td>)}
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
          {rows.length>1000 && <div className="text-xs text-gray-500 mt-2">Showing first 1000 rows.</div>}
        </div>
      </div>
    </div>
  );
}

/* helpers */
function download(filename, mime, text){
  const blob = new Blob([text], {type:mime}); const a=document.createElement('a');
  a.href = URL.createObjectURL(blob); a.download = filename; a.click(); URL.revokeObjectURL(a.href);
}

/* mount */
ReactDOM.createRoot(document.getElementById('app')).render(<App />);
</script>
</body>
</html>
